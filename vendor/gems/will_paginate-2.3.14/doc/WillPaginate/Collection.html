<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

	<title>Class: WillPaginate::Collection</title>

	<link rel="stylesheet" href="../rdoc.css" type="text/css" media="screen" />

	<script src="../js/jquery.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../js/thickbox-compressed.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../js/quicksearch.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../js/darkfish.js" type="text/javascript"
		charset="utf-8"></script>

</head>
<body class="class">

	<div id="metadata">
		<div id="home-metadata">
			<div id="home-section" class="section">
        <h3 class="section-header">
          <a href="../index.html">Home</a>
          <a href="../index.html#classes">Classes</a>
          <a href="../index.html#methods">Methods</a>
        </h3>
			</div>
		</div>

		<div id="file-metadata">
			<div id="file-list-section" class="section">
				<h3 class="section-header">In Files</h3>
				<div class="section-body">
					<ul>
					
						<li><a href="../lib/will_paginate/collection_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
							class="thickbox" title="lib/will_paginate/collection.rb">lib/will_paginate/collection.rb</a></li>
					
					</ul>
				</div>
			</div>

			
		</div>

		<div id="class-metadata">

			<!-- Parent Class -->
			
			<div id="parent-class-section" class="section">
				<h3 class="section-header">Parent</h3>
				
				<p class="link"><a href="../Array.html">Array</a></p>
				
			</div>
			

			<!-- Namespace Contents -->
			

			<!-- Method Quickref -->
			
			<div id="method-list-section" class="section">
				<h3 class="section-header">Methods</h3>
				<ul class="link-list">
					
					<li><a href="#method-c-create">::create</a></li>
					
					<li><a href="#method-c-new">::new</a></li>
					
					<li><a href="#method-i-next_page">#next_page</a></li>
					
					<li><a href="#method-i-offset">#offset</a></li>
					
					<li><a href="#method-i-out_of_bounds%3F">#out_of_bounds?</a></li>
					
					<li><a href="#method-i-previous_page">#previous_page</a></li>
					
					<li><a href="#method-i-replace">#replace</a></li>
					
					<li><a href="#method-i-total_entries%3D">#total_entries=</a></li>
					
				</ul>
			</div>
			

			<!-- Included Modules -->
			
		</div>

		<div id="project-metadata">
			
			
			<div id="fileindex-section" class="section project-section">
				<h3 class="section-header">Files</h3>
				<ul>
				
					<li class="file"><a href="../CHANGELOG_rdoc.html">CHANGELOG.rdoc</a></li>
				
					<li class="file"><a href="../LICENSE.html">LICENSE</a></li>
				
					<li class="file"><a href="../README_rdoc.html">README.rdoc</a></li>
				
				</ul>
			</div>
			

			<div id="classindex-section" class="section project-section">
				<h3 class="section-header">Class Index
					<span class="search-toggle"><img src="../images/find.png"
						height="16" width="16" alt="[+]"
						title="show/hide quicksearch" /></span></h3>
				<form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
				<fieldset>
					<legend>Quicksearch</legend>
					<input type="text" name="quicksearch" value=""
						class="quicksearch-field" />
				</fieldset>
				</form>

				<ul class="link-list">
				
					<li><a href="../WillPaginate.html">WillPaginate</a></li>
				
					<li><a href="../WillPaginate/Collection.html">WillPaginate::Collection</a></li>
				
					<li><a href="../WillPaginate/Finder.html">WillPaginate::Finder</a></li>
				
					<li><a href="../WillPaginate/Finder/ClassMethods.html">WillPaginate::Finder::ClassMethods</a></li>
				
					<li><a href="../WillPaginate/Finder/base.html">WillPaginate::Finder::base</a></li>
				
					<li><a href="../WillPaginate/InvalidPage.html">WillPaginate::InvalidPage</a></li>
				
					<li><a href="../WillPaginate/LinkRenderer.html">WillPaginate::LinkRenderer</a></li>
				
					<li><a href="../WillPaginate/ViewHelpers.html">WillPaginate::ViewHelpers</a></li>
				
					<li><a href="../WillPaginate/ViewHelpers/collection.html">WillPaginate::ViewHelpers::collection</a></li>
				
					<li><a href="../Array.html">Array</a></li>
				
					<li><a href="../Object.html">Object</a></li>
				
				</ul>
				<div id="no-class-search-results" style="display: none;">No matching classes.</div>
			</div>

			
		</div>
	</div>

	<div id="documentation">
		<h1 class="class">WillPaginate::Collection</h1>

		<div id="description">
			<h1>The key to pagination</h1>
<p>
Arrays returned from paginating finds are, in fact, instances of this
little class. You may think of <a
href="Collection.html">WillPaginate::Collection</a> as an ordinary array
with some extra properties. Those properties are used by view helpers to
generate correct page links.
</p>
<p>
<a href="Collection.html">WillPaginate::Collection</a> also assists in
rolling out your own pagination solutions: see <tt>create</tt>.
</p>
<p>
If you are writing a library that provides a collection which you would
like to conform to this API, you don&#8217;t have to copy these methods
over; simply make your plugin/gem dependant on this library and do:
</p>
<pre>
  require 'will_paginate/collection'
  # WillPaginate::Collection is now available for use</pre>

		</div>

		<!-- Constants -->
		

		<!-- Attributes -->
		
		<div id="attribute-method-details" class="method-section section">
			<h3 class="section-header">Attributes</h3>

			
			<div id="current-page-attribute-method" class="method-detail">
				<a name="current_page"></a>
				
				<div class="method-heading attribute-method-heading">
					<span class="method-name">current_page</span><span
						class="attribute-access-type">[R]</span>
				</div>

				<div class="method-description">
				
				
				
				</div>
			</div>
			
			<div id="per-page-attribute-method" class="method-detail">
				<a name="per_page"></a>
				
				<div class="method-heading attribute-method-heading">
					<span class="method-name">per_page</span><span
						class="attribute-access-type">[R]</span>
				</div>

				<div class="method-description">
				
				
				
				</div>
			</div>
			
			<div id="total-entries-attribute-method" class="method-detail">
				<a name="total_entries"></a>
				
				<div class="method-heading attribute-method-heading">
					<span class="method-name">total_entries</span><span
						class="attribute-access-type">[R]</span>
				</div>

				<div class="method-description">
				
				
				
				</div>
			</div>
			
			<div id="total-pages-attribute-method" class="method-detail">
				<a name="total_pages"></a>
				
				<div class="method-heading attribute-method-heading">
					<span class="method-name">total_pages</span><span
						class="attribute-access-type">[R]</span>
				</div>

				<div class="method-description">
				
				
				
				</div>
			</div>
			
		</div>
		

		<!-- Methods -->
		
		<div id="public-class-method-details" class="method-section section">
			<h3 class="section-header">Public Class Methods</h3>

		
			<div id="create-method" class="method-detail ">
				<a name="method-c-create"></a>

				<div class="method-heading">
				
					<span class="method-name">create</span><span
						class="method-args">(page, per_page, total = nil)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Just like <tt>new</tt>, but yields the object after instantiation and
returns it afterwards. This is very useful for manual pagination:
</p>
<pre>
  @entries = WillPaginate::Collection.create(1, 10) do |pager|
    result = Post.find(:all, :limit =&gt; pager.per_page, :offset =&gt; pager.offset)
    # inject the result array into the paginated collection:
    pager.replace(result)

    unless pager.total_entries
      # the pager didn't manage to guess the total count, do it manually
      pager.total_entries = Post.count
    end
  end
</pre>
<p>
The possibilities with this are endless. For another example, here is how
<a href="../WillPaginate.html">WillPaginate</a> used to define pagination
for <a href="../Array.html">Array</a> instances:
</p>
<pre>
  Array.class_eval do
    def paginate(page = 1, per_page = 15)
      WillPaginate::Collection.create(page, per_page, size) do |pager|
        pager.replace self[pager.offset, pager.per_page].to_a
      end
    end
  end
</pre>
<p>
The Array#paginate API has since then changed, but this still serves as a
fine example of <a href="Collection.html">WillPaginate::Collection</a>
usage.
</p>
					

					
					<div class="method-source-code"
						id="create-source">
<pre>
    <span class="ruby-comment cmt"># File lib/will_paginate/collection.rb, line 83</span>
83:     <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">page</span>, <span class="ruby-identifier">per_page</span>, <span class="ruby-identifier">total</span> = <span class="ruby-keyword kw">nil</span>)
84:       <span class="ruby-identifier">pager</span> = <span class="ruby-identifier">new</span>(<span class="ruby-identifier">page</span>, <span class="ruby-identifier">per_page</span>, <span class="ruby-identifier">total</span>)
85:       <span class="ruby-keyword kw">yield</span> <span class="ruby-identifier">pager</span>
86:       <span class="ruby-identifier">pager</span>
87:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="new-method" class="method-detail ">
				<a name="method-c-new"></a>

				<div class="method-heading">
				
					<span class="method-name">new</span><span
						class="method-args">(page, per_page, total = nil)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Arguments to the constructor are the current page number, per-page limit
and the total number of entries. The last argument is optional because it
is best to do lazy counting; in other words, count <b>conditionally</b>
after populating the collection using the <tt>replace</tt> method.
</p>
					

					
					<div class="method-source-code"
						id="new-source">
<pre>
    <span class="ruby-comment cmt"># File lib/will_paginate/collection.rb, line 47</span>
47:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">page</span>, <span class="ruby-identifier">per_page</span>, <span class="ruby-identifier">total</span> = <span class="ruby-keyword kw">nil</span>)
48:       <span class="ruby-ivar">@current_page</span> = <span class="ruby-identifier">page</span>.<span class="ruby-identifier">to_i</span>
49:       <span class="ruby-identifier">raise</span> <span class="ruby-constant">InvalidPage</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">page</span>, <span class="ruby-ivar">@current_page</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@current_page</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">1</span>
50:       <span class="ruby-ivar">@per_page</span> = <span class="ruby-identifier">per_page</span>.<span class="ruby-identifier">to_i</span>
51:       <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-node">&quot;`per_page` setting cannot be less than 1 (#{@per_page} given)&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@per_page</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">1</span>
52:       
53:       <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">total_entries</span> = <span class="ruby-identifier">total</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">total</span>
54:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
		</div>
	
		<div id="public-instance-method-details" class="method-section section">
			<h3 class="section-header">Public Instance Methods</h3>

		
			<div id="next-page-method" class="method-detail ">
				<a name="method-i-next_page"></a>

				<div class="method-heading">
				
					<span class="method-name">next_page</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Collection.html#current_page">current_page</a> + 1 or nil if there
is no next page
</p>
					

					
					<div class="method-source-code"
						id="next-page-source">
<pre>
     <span class="ruby-comment cmt"># File lib/will_paginate/collection.rb, line 110</span>
110:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">next_page</span>
111:       <span class="ruby-identifier">current_page</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">total_pages</span> <span class="ruby-operator">?</span> (<span class="ruby-identifier">current_page</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>) <span class="ruby-operator">:</span> <span class="ruby-keyword kw">nil</span>
112:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="offset-method" class="method-detail ">
				<a name="method-i-offset"></a>

				<div class="method-heading">
				
					<span class="method-name">offset</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Current offset of the paginated collection. If we&#8217;re on the first
page, it is always 0. If we&#8217;re on the 2nd page and there are 30
entries per page, the offset is 30. This property is useful if you want to
render ordinals side by side with records in the view: simply start with
offset + 1.
</p>
					

					
					<div class="method-source-code"
						id="offset-source">
<pre>
     <span class="ruby-comment cmt"># File lib/will_paginate/collection.rb, line 100</span>
100:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">offset</span>
101:       (<span class="ruby-identifier">current_page</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>) * <span class="ruby-identifier">per_page</span>
102:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="out-of-bounds--method" class="method-detail ">
				<a name="method-i-out_of_bounds%3F"></a>

				<div class="method-heading">
				
					<span class="method-name">out_of_bounds?</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Helper method that is true when someone tries to fetch a page with a larger
number than the last page. Can be used in combination with flashes and
redirecting.
</p>
					

					
					<div class="method-source-code"
						id="out-of-bounds--source">
<pre>
    <span class="ruby-comment cmt"># File lib/will_paginate/collection.rb, line 92</span>
92:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">out_of_bounds?</span>
93:       <span class="ruby-identifier">current_page</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">total_pages</span>
94:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="previous-page-method" class="method-detail ">
				<a name="method-i-previous_page"></a>

				<div class="method-heading">
				
					<span class="method-name">previous_page</span><span
						class="method-args">()</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
<a href="Collection.html#current_page">current_page</a> - 1 or nil if there
is no previous page
</p>
					

					
					<div class="method-source-code"
						id="previous-page-source">
<pre>
     <span class="ruby-comment cmt"># File lib/will_paginate/collection.rb, line 105</span>
105:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">previous_page</span>
106:       <span class="ruby-identifier">current_page</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span> <span class="ruby-operator">?</span> (<span class="ruby-identifier">current_page</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>) <span class="ruby-operator">:</span> <span class="ruby-keyword kw">nil</span>
107:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="replace-method" class="method-detail ">
				<a name="method-i-replace"></a>

				<div class="method-heading">
				
					<span class="method-name">replace</span><span
						class="method-args">(array)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
This is a magic wrapper for the original Array#replace method. It serves
for populating the paginated collection after initialization.
</p>
<p>
Why magic? Because it tries to guess the total number of entries judging by
the size of given array. If it is shorter than <tt><a
href="Collection.html#per_page">per_page</a></tt> limit, then we know
we&#8217;re on the last page. This trick is very useful for avoiding
unnecessary hits to the database to do the counting after we fetched the
data for the current page.
</p>
<p>
However, after using <tt>replace</tt> you should always test the value of
<tt><a href="Collection.html#total_entries">total_entries</a></tt> and set
it to a proper value if it&#8217;s <tt>nil</tt>. See the example in
<tt>create</tt>.
</p>
					

					
					<div class="method-source-code"
						id="replace-source">
<pre>
     <span class="ruby-comment cmt"># File lib/will_paginate/collection.rb, line 132</span>
132:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">replace</span>(<span class="ruby-identifier">array</span>)
133:       <span class="ruby-identifier">result</span> = <span class="ruby-keyword kw">super</span>
134:       
135:       <span class="ruby-comment cmt"># The collection is shorter then page limit? Rejoice, because</span>
136:       <span class="ruby-comment cmt"># then we know that we are on the last page!</span>
137:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">total_entries</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">per_page</span> <span class="ruby-keyword kw">and</span> (<span class="ruby-identifier">current_page</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>)
138:         <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">total_entries</span> = <span class="ruby-identifier">offset</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">length</span>
139:       <span class="ruby-keyword kw">end</span>
140: 
141:       <span class="ruby-identifier">result</span>
142:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="total-entries--method" class="method-detail ">
				<a name="method-i-total_entries%3D"></a>

				<div class="method-heading">
				
					<span class="method-name">total_entries=</span><span
						class="method-args">(number)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
sets the <tt><a href="Collection.html#total_entries">total_entries</a></tt>
property and calculates <tt><a
href="Collection.html#total_pages">total_pages</a></tt>
</p>
					

					
					<div class="method-source-code"
						id="total-entries--source">
<pre>
     <span class="ruby-comment cmt"># File lib/will_paginate/collection.rb, line 115</span>
115:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">total_entries=</span>(<span class="ruby-identifier">number</span>)
116:       <span class="ruby-ivar">@total_entries</span> = <span class="ruby-identifier">number</span>.<span class="ruby-identifier">to_i</span>
117:       <span class="ruby-ivar">@total_pages</span>   = (<span class="ruby-ivar">@total_entries</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">per_page</span>.<span class="ruby-identifier">to_f</span>).<span class="ruby-identifier">ceil</span>
118:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
		</div>
	

	</div>


	<div id="rdoc-debugging-section-dump" class="debugging-section">
	
		<p>Disabled; run with --debug to generate this.</p>
	
	</div>

	<div id="validator-badges">
		<p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
		<p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
			Rdoc Generator</a> 1.1.6</small>.</p>
	</div>

</body>
</html>

