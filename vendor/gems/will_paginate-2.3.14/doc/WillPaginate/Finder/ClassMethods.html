<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

	<title>Module: WillPaginate::Finder::ClassMethods</title>

	<link rel="stylesheet" href="../../rdoc.css" type="text/css" media="screen" />

	<script src="../../js/jquery.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../../js/thickbox-compressed.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../../js/quicksearch.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../../js/darkfish.js" type="text/javascript"
		charset="utf-8"></script>

</head>
<body class="module">

	<div id="metadata">
		<div id="home-metadata">
			<div id="home-section" class="section">
        <h3 class="section-header">
          <a href="../../index.html">Home</a>
          <a href="../../index.html#classes">Classes</a>
          <a href="../../index.html#methods">Methods</a>
        </h3>
			</div>
		</div>

		<div id="file-metadata">
			<div id="file-list-section" class="section">
				<h3 class="section-header">In Files</h3>
				<div class="section-body">
					<ul>
					
						<li><a href="../../lib/will_paginate/finder_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
							class="thickbox" title="lib/will_paginate/finder.rb">lib/will_paginate/finder.rb</a></li>
					
					</ul>
				</div>
			</div>

			
		</div>

		<div id="class-metadata">

			<!-- Parent Class -->
			

			<!-- Namespace Contents -->
			

			<!-- Method Quickref -->
			
			<div id="method-list-section" class="section">
				<h3 class="section-header">Methods</h3>
				<ul class="link-list">
					
					<li><a href="#method-i-paginate">#paginate</a></li>
					
					<li><a href="#method-i-paginate_by_sql">#paginate_by_sql</a></li>
					
					<li><a href="#method-i-paginated_each">#paginated_each</a></li>
					
					<li><a href="#method-i-wp_count">#wp_count</a></li>
					
				</ul>
			</div>
			

			<!-- Included Modules -->
			
		</div>

		<div id="project-metadata">
			
			
			<div id="fileindex-section" class="section project-section">
				<h3 class="section-header">Files</h3>
				<ul>
				
					<li class="file"><a href="../../CHANGELOG_rdoc.html">CHANGELOG.rdoc</a></li>
				
					<li class="file"><a href="../../LICENSE.html">LICENSE</a></li>
				
					<li class="file"><a href="../../README_rdoc.html">README.rdoc</a></li>
				
				</ul>
			</div>
			

			<div id="classindex-section" class="section project-section">
				<h3 class="section-header">Class Index
					<span class="search-toggle"><img src="../../images/find.png"
						height="16" width="16" alt="[+]"
						title="show/hide quicksearch" /></span></h3>
				<form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
				<fieldset>
					<legend>Quicksearch</legend>
					<input type="text" name="quicksearch" value=""
						class="quicksearch-field" />
				</fieldset>
				</form>

				<ul class="link-list">
				
					<li><a href="../../WillPaginate.html">WillPaginate</a></li>
				
					<li><a href="../../WillPaginate/Collection.html">WillPaginate::Collection</a></li>
				
					<li><a href="../../WillPaginate/Finder.html">WillPaginate::Finder</a></li>
				
					<li><a href="../../WillPaginate/Finder/ClassMethods.html">WillPaginate::Finder::ClassMethods</a></li>
				
					<li><a href="../../WillPaginate/Finder/base.html">WillPaginate::Finder::base</a></li>
				
					<li><a href="../../WillPaginate/InvalidPage.html">WillPaginate::InvalidPage</a></li>
				
					<li><a href="../../WillPaginate/LinkRenderer.html">WillPaginate::LinkRenderer</a></li>
				
					<li><a href="../../WillPaginate/ViewHelpers.html">WillPaginate::ViewHelpers</a></li>
				
					<li><a href="../../WillPaginate/ViewHelpers/collection.html">WillPaginate::ViewHelpers::collection</a></li>
				
					<li><a href="../../Array.html">Array</a></li>
				
					<li><a href="../../Object.html">Object</a></li>
				
				</ul>
				<div id="no-class-search-results" style="display: none;">No matching classes.</div>
			</div>

			
		</div>
	</div>

	<div id="documentation">
		<h1 class="module">WillPaginate::Finder::ClassMethods</h1>

		<div id="description">
			<h1>Paginating finders for ActiveRecord models</h1>
<p>
<a href="../../WillPaginate.html">WillPaginate</a> adds <tt>paginate</tt>,
<tt>per_page</tt> and other methods to ActiveRecord::Base class methods and
associations. It also hooks into <tt>method_missing</tt> to intercept
pagination calls to dynamic finders such as <tt>paginate_by_user_id</tt>
and translate them to ordinary finders (<tt>find_all_by_user_id</tt> in
this case).
</p>
<p>
In short, paginating finders are equivalent to ActiveRecord finders; the
only difference is that we start with &#8220;paginate&#8221; instead of
&#8220;find&#8221; and that <tt>:page</tt> is required parameter:
</p>
<pre>
  @posts = Post.paginate :all, :page =&gt; params[:page], :order =&gt; 'created_at DESC'
</pre>
<p>
In paginating finders, &#8220;all&#8221; is implicit. There is no sense in
paginating a single record, right? So, you can drop the <tt>:all</tt>
argument:
</p>
<pre>
  Post.paginate(...)              =&gt;  Post.find :all
  Post.paginate_all_by_something  =&gt;  Post.find_all_by_something
  Post.paginate_by_something      =&gt;  Post.find_all_by_something
</pre>
<h2>The importance of the <tt>:order</tt> parameter</h2>
<p>
In ActiveRecord finders, <tt>:order</tt> parameter specifies columns for
the <tt>ORDER BY</tt> clause in SQL. It is important to have it, since
pagination only makes sense with ordered sets. Without the <tt>ORDER
BY</tt> clause, databases aren&#8217;t required to do consistent ordering
when performing <tt>SELECT</tt> queries; this is especially true for
PostgreSQL.
</p>
<p>
Therefore, make sure you are doing ordering on a column that makes the most
sense in the current context. Make that obvious to the user, also. For
perfomance reasons you will also want to add an index to that column.
</p>

		</div>

		<!-- Constants -->
		

		<!-- Attributes -->
		

		<!-- Methods -->
		
		<div id="public-instance-method-details" class="method-section section">
			<h3 class="section-header">Public Instance Methods</h3>

		
			<div id="paginate-method" class="method-detail ">
				<a name="method-i-paginate"></a>

				<div class="method-heading">
				
					<span class="method-name">paginate</span><span
						class="method-args">(*args)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
This is the main paginating finder.
</p>
<h2>Special parameters for paginating finders</h2>
<ul>
<li><p>
<tt>:page</tt> &#8212; REQUIRED, but defaults to 1 if false or nil
</p>
</li>
<li><p>
<tt>:per_page</tt> &#8212; defaults to <tt>CurrentModel.per_page</tt>
(which is 30 if not overridden)
</p>
</li>
<li><p>
<tt>:total_entries</tt> &#8212; use only if you manually count total
entries
</p>
</li>
<li><p>
<tt>:count</tt> &#8212; additional options that are passed on to
<tt>count</tt>
</p>
</li>
<li><p>
<tt>:finder</tt> &#8212; name of the ActiveRecord finder used (default:
&#8220;find&#8221;)
</p>
</li>
</ul>
<p>
All other options (<tt>conditions</tt>, <tt>order</tt>, &#8230;) are
forwarded to <tt>find</tt> and <tt>count</tt> calls.
</p>
					

					
					<div class="method-source-code"
						id="paginate-source">
<pre>
    <span class="ruby-comment cmt"># File lib/will_paginate/finder.rb, line 64</span>
64:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">paginate</span>(*<span class="ruby-identifier">args</span>)
65:         <span class="ruby-identifier">options</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">pop</span>
66:         <span class="ruby-identifier">page</span>, <span class="ruby-identifier">per_page</span>, <span class="ruby-identifier">total_entries</span> = <span class="ruby-identifier">wp_parse_options</span>(<span class="ruby-identifier">options</span>)
67:         <span class="ruby-identifier">finder</span> = (<span class="ruby-identifier">options</span>[<span class="ruby-value">:finder</span>] <span class="ruby-operator">||</span> <span class="ruby-value str">'find'</span>).<span class="ruby-identifier">to_s</span>
68: 
69:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">finder</span> <span class="ruby-operator">==</span> <span class="ruby-value str">'find'</span>
70:           <span class="ruby-comment cmt"># an array of IDs may have been given:</span>
71:           <span class="ruby-identifier">total_entries</span> <span class="ruby-operator">||=</span> (<span class="ruby-constant">Array</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">first</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">size</span>)
72:           <span class="ruby-comment cmt"># :all is implicit</span>
73:           <span class="ruby-identifier">args</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-value">:all</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">empty?</span>
74:         <span class="ruby-keyword kw">end</span>
75: 
76:         <span class="ruby-constant">WillPaginate</span><span class="ruby-operator">::</span><span class="ruby-constant">Collection</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">page</span>, <span class="ruby-identifier">per_page</span>, <span class="ruby-identifier">total_entries</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">pager</span><span class="ruby-operator">|</span>
77:           <span class="ruby-identifier">count_options</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">except</span> <span class="ruby-value">:page</span>, <span class="ruby-value">:per_page</span>, <span class="ruby-value">:total_entries</span>, <span class="ruby-value">:finder</span>
78:           <span class="ruby-identifier">find_options</span> = <span class="ruby-identifier">count_options</span>.<span class="ruby-identifier">except</span>(<span class="ruby-value">:count</span>).<span class="ruby-identifier">update</span>(<span class="ruby-value">:offset</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">pager</span>.<span class="ruby-identifier">offset</span>, <span class="ruby-value">:limit</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">pager</span>.<span class="ruby-identifier">per_page</span>) 
79:           
80:           <span class="ruby-identifier">args</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">find_options</span>
81:           <span class="ruby-comment cmt"># @options_from_last_find = nil</span>
82:           <span class="ruby-identifier">pager</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">send</span>(<span class="ruby-identifier">finder</span>, *<span class="ruby-identifier">args</span>) { <span class="ruby-operator">|</span>*<span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-keyword kw">yield</span>(*<span class="ruby-identifier">a</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">block_given?</span> })
83:           
84:           <span class="ruby-comment cmt"># magic counting for user convenience:</span>
85:           <span class="ruby-identifier">pager</span>.<span class="ruby-identifier">total_entries</span> = <span class="ruby-identifier">wp_count</span>(<span class="ruby-identifier">count_options</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">finder</span>) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">pager</span>.<span class="ruby-identifier">total_entries</span>
86:         <span class="ruby-keyword kw">end</span>
87:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="paginate-by-sql-method" class="method-detail ">
				<a name="method-i-paginate_by_sql"></a>

				<div class="method-heading">
				
					<span class="method-name">paginate_by_sql</span><span
						class="method-args">(sql, options)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Wraps <tt>find_by_sql</tt> by simply adding LIMIT and OFFSET to your SQL
string based on the params otherwise used by paginating finds:
<tt>page</tt> and <tt>per_page</tt>.
</p>
<p>
Example:
</p>
<pre>
  @developers = Developer.paginate_by_sql ['select * from developers where salary &gt; ?', 80000],
                         :page =&gt; params[:page], :per_page =&gt; 3
</pre>
<p>
A query for counting rows will automatically be generated if you
don&#8217;t supply <tt>:total_entries</tt>. If you experience problems with
this generated SQL, you might want to perform the count manually in your
application.
</p>
					

					
					<div class="method-source-code"
						id="paginate-by-sql-source">
<pre>
     <span class="ruby-comment cmt"># File lib/will_paginate/finder.rb, line 131</span>
131:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">paginate_by_sql</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">options</span>)
132:         <span class="ruby-constant">WillPaginate</span><span class="ruby-operator">::</span><span class="ruby-constant">Collection</span>.<span class="ruby-identifier">create</span>(*<span class="ruby-identifier">wp_parse_options</span>(<span class="ruby-identifier">options</span>)) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">pager</span><span class="ruby-operator">|</span>
133:           <span class="ruby-identifier">query</span> = <span class="ruby-identifier">sanitize_sql</span>(<span class="ruby-identifier">sql</span>.<span class="ruby-identifier">dup</span>)
134:           <span class="ruby-identifier">original_query</span> = <span class="ruby-identifier">query</span>.<span class="ruby-identifier">dup</span>
135:           <span class="ruby-comment cmt"># add limit, offset</span>
136:           <span class="ruby-identifier">add_limit!</span> <span class="ruby-identifier">query</span>, <span class="ruby-value">:offset</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">pager</span>.<span class="ruby-identifier">offset</span>, <span class="ruby-value">:limit</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">pager</span>.<span class="ruby-identifier">per_page</span>
137:           <span class="ruby-comment cmt"># perfom the find</span>
138:           <span class="ruby-identifier">pager</span>.<span class="ruby-identifier">replace</span> <span class="ruby-identifier">find_by_sql</span>(<span class="ruby-identifier">query</span>)
139:           
140:           <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">pager</span>.<span class="ruby-identifier">total_entries</span>
141:             <span class="ruby-identifier">count_query</span> = <span class="ruby-identifier">original_query</span>.<span class="ruby-identifier">sub</span> <span class="ruby-regexp re">/\bORDER\s+BY\s+[\w`,\s]+$/</span><span class="ruby-identifier">i</span>, <span class="ruby-value str">''</span>
142:             <span class="ruby-identifier">count_query</span> = <span class="ruby-node">&quot;SELECT COUNT(*) FROM (#{count_query})&quot;</span>
143:             
144:             <span class="ruby-keyword kw">unless</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">adapter_name</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/^(oracle|oci$)/</span>
145:               <span class="ruby-identifier">count_query</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">' AS count_table'</span>
146:             <span class="ruby-keyword kw">end</span>
147:             <span class="ruby-comment cmt"># perform the count query</span>
148:             <span class="ruby-identifier">pager</span>.<span class="ruby-identifier">total_entries</span> = <span class="ruby-identifier">count_by_sql</span>(<span class="ruby-identifier">count_query</span>)
149:           <span class="ruby-keyword kw">end</span>
150:         <span class="ruby-keyword kw">end</span>
151:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
			<div id="paginated-each-method" class="method-detail ">
				<a name="method-i-paginated_each"></a>

				<div class="method-heading">
				
					<span class="method-name">paginated_each</span><span
						class="method-args">(options = {})</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Iterates through all records by loading one page at a time. This is useful
for migrations or any other use case where you don&#8217;t want to load all
the records in memory at once.
</p>
<p>
It uses <tt>paginate</tt> internally; therefore it accepts all of its
options. You can specify a starting page with <tt>:page</tt> (default is
1). Default <tt>:order</tt> is <tt>&quot;id&quot;</tt>, override if
necessary.
</p>
<p>
See <a
href="http://weblog.jamisbuck.org/2007/4/6/faking-cursors-in-activerecord">Faking
Cursors in ActiveRecord</a> where Jamis Buck describes this and a more
efficient way for MySQL.
</p>
					

					
					<div class="method-source-code"
						id="paginated-each-source">
<pre>
     <span class="ruby-comment cmt"># File lib/will_paginate/finder.rb, line 99</span>
 99:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">paginated_each</span>(<span class="ruby-identifier">options</span> = {})
100:         <span class="ruby-identifier">options</span> = { <span class="ruby-value">:order</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value str">'id'</span>, <span class="ruby-value">:page</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span> }.<span class="ruby-identifier">merge</span> <span class="ruby-identifier">options</span>
101:         <span class="ruby-identifier">options</span>[<span class="ruby-value">:page</span>] = <span class="ruby-identifier">options</span>[<span class="ruby-value">:page</span>].<span class="ruby-identifier">to_i</span>
102:         <span class="ruby-identifier">options</span>[<span class="ruby-value">:total_entries</span>] = <span class="ruby-value">0</span> <span class="ruby-comment cmt"># skip the individual count queries</span>
103:         <span class="ruby-identifier">total</span> = <span class="ruby-value">0</span>
104:         
105:         <span class="ruby-keyword kw">begin</span> 
106:           <span class="ruby-identifier">collection</span> = <span class="ruby-identifier">paginate</span>(<span class="ruby-identifier">options</span>)
107:           <span class="ruby-identifier">with_exclusive_scope</span>(<span class="ruby-value">:find</span> =<span class="ruby-operator">&gt;</span> {}) <span class="ruby-keyword kw">do</span>
108:             <span class="ruby-comment cmt"># using exclusive scope so that the block is yielded in scope-free context</span>
109:             <span class="ruby-identifier">total</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">collection</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">item</span><span class="ruby-operator">|</span> <span class="ruby-keyword kw">yield</span> <span class="ruby-identifier">item</span> }.<span class="ruby-identifier">size</span>
110:           <span class="ruby-keyword kw">end</span>
111:           <span class="ruby-identifier">options</span>[<span class="ruby-value">:page</span>] <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
112:         <span class="ruby-keyword kw">end</span> <span class="ruby-keyword kw">until</span> <span class="ruby-identifier">collection</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">collection</span>.<span class="ruby-identifier">per_page</span>
113:         
114:         <span class="ruby-identifier">total</span>
115:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
		</div>
	
		<div id="protected-instance-method-details" class="method-section section">
			<h3 class="section-header">Protected Instance Methods</h3>

		
			<div id="wp-count-method" class="method-detail ">
				<a name="method-i-wp_count"></a>

				<div class="method-heading">
				
					<span class="method-name">wp_count</span><span
						class="method-args">(options, args, finder)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Does the not-so-trivial job of finding out the total number of entries in
the database. It relies on the ActiveRecord <tt>count</tt> method.
</p>
					

					
					<div class="method-source-code"
						id="wp-count-source">
<pre>
     <span class="ruby-comment cmt"># File lib/will_paginate/finder.rb, line 189</span>
189:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">wp_count</span>(<span class="ruby-identifier">options</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">finder</span>)
190:         <span class="ruby-identifier">excludees</span> = [<span class="ruby-value">:count</span>, <span class="ruby-value">:order</span>, <span class="ruby-value">:limit</span>, <span class="ruby-value">:offset</span>, <span class="ruby-value">:readonly</span>]
191:         <span class="ruby-identifier">excludees</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">:from</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Calculations</span><span class="ruby-operator">::</span><span class="ruby-constant">CALCULATIONS_OPTIONS</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-value">:from</span>)
192: 
193:         <span class="ruby-comment cmt"># we may be in a model or an association proxy</span>
194:         <span class="ruby-identifier">klass</span> = (<span class="ruby-ivar">@owner</span> <span class="ruby-keyword kw">and</span> <span class="ruby-ivar">@reflection</span>) <span class="ruby-operator">?</span> <span class="ruby-ivar">@reflection</span>.<span class="ruby-identifier">klass</span> <span class="ruby-operator">:</span> <span class="ruby-keyword kw">self</span>
195: 
196:         <span class="ruby-comment cmt"># Use :select from scope if it isn't already present.</span>
197:         <span class="ruby-identifier">options</span>[<span class="ruby-value">:select</span>] = <span class="ruby-identifier">scope</span>(<span class="ruby-value">:find</span>, <span class="ruby-value">:select</span>) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:select</span>]
198: 
199:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:select</span>] <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:select</span>] <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/^\s*DISTINCT\b/</span>
200:           <span class="ruby-comment cmt"># Remove quoting and check for table_name.*-like statement.</span>
201:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:select</span>].<span class="ruby-identifier">gsub</span>(<span class="ruby-value str">'`'</span>, <span class="ruby-value str">''</span>) <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/\w+\.\*/</span>
202:             <span class="ruby-identifier">options</span>[<span class="ruby-value">:select</span>] = <span class="ruby-node">&quot;DISTINCT #{klass.table_name}.#{klass.primary_key}&quot;</span>
203:           <span class="ruby-keyword kw">end</span>
204:         <span class="ruby-keyword kw">else</span>
205:           <span class="ruby-identifier">excludees</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">:select</span> <span class="ruby-comment cmt"># only exclude the select param if it doesn't begin with DISTINCT</span>
206:         <span class="ruby-keyword kw">end</span>
207: 
208:         <span class="ruby-comment cmt"># count expects (almost) the same options as find</span>
209:         <span class="ruby-identifier">count_options</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">except</span> *<span class="ruby-identifier">excludees</span>
210: 
211:         <span class="ruby-comment cmt"># merge the hash found in :count</span>
212:         <span class="ruby-comment cmt"># this allows you to specify :select, :order, or anything else just for the count query</span>
213:         <span class="ruby-identifier">count_options</span>.<span class="ruby-identifier">update</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:count</span>] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:count</span>]
214: 
215:         <span class="ruby-comment cmt"># forget about includes if they are irrelevant (Rails 2.1)</span>
216:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">count_options</span>[<span class="ruby-value">:include</span>] <span class="ruby-keyword kw">and</span>
217:             <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">private_methods</span>.<span class="ruby-identifier">include_method?</span>(<span class="ruby-value">:references_eager_loaded_tables?</span>) <span class="ruby-keyword kw">and</span>
218:             <span class="ruby-operator">!</span><span class="ruby-identifier">klass</span>.<span class="ruby-identifier">send</span>(<span class="ruby-value">:references_eager_loaded_tables?</span>, <span class="ruby-identifier">count_options</span>)
219:           <span class="ruby-identifier">count_options</span>.<span class="ruby-identifier">delete</span> <span class="ruby-value">:include</span>
220:         <span class="ruby-keyword kw">end</span>
221: 
222:         <span class="ruby-comment cmt"># we may have to scope ...</span>
223:         <span class="ruby-identifier">counter</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">count</span>(<span class="ruby-identifier">count_options</span>) }
224: 
225:         <span class="ruby-identifier">count</span> = <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">finder</span>.<span class="ruby-identifier">index</span>(<span class="ruby-value str">'find_'</span>) <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">scoper</span> = <span class="ruby-identifier">finder</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-value str">'find'</span>, <span class="ruby-value str">'with'</span>))
226:                   <span class="ruby-comment cmt"># scope_out adds a 'with_finder' method which acts like with_scope, if it's present</span>
227:                   <span class="ruby-comment cmt"># then execute the count with the scoping provided by the with_finder</span>
228:                   <span class="ruby-identifier">send</span>(<span class="ruby-identifier">scoper</span>, &amp;<span class="ruby-identifier">counter</span>)
229:                 <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">finder</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/^find_(all_by|by)_([_a-zA-Z]\w*)$/</span>
230:                   <span class="ruby-comment cmt"># extract conditions from calls like &quot;paginate_by_foo_and_bar&quot;</span>
231:                   <span class="ruby-identifier">attribute_names</span> = <span class="ruby-node">$2</span>.<span class="ruby-identifier">split</span>(<span class="ruby-value str">'_and_'</span>)
232:                   <span class="ruby-identifier">conditions</span> = <span class="ruby-identifier">construct_attributes_from_arguments</span>(<span class="ruby-identifier">attribute_names</span>, <span class="ruby-identifier">args</span>)
233:                   <span class="ruby-identifier">with_scope</span>(<span class="ruby-value">:find</span> =<span class="ruby-operator">&gt;</span> { <span class="ruby-value">:conditions</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">conditions</span> }, &amp;<span class="ruby-identifier">counter</span>)
234:                 <span class="ruby-keyword kw">else</span>
235:                   <span class="ruby-identifier">counter</span>.<span class="ruby-identifier">call</span>
236:                 <span class="ruby-keyword kw">end</span>
237: 
238:         <span class="ruby-identifier">count</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:length</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">count</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">count</span>
239:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				

				
			</div>

		
		</div>
	

	</div>


	<div id="rdoc-debugging-section-dump" class="debugging-section">
	
		<p>Disabled; run with --debug to generate this.</p>
	
	</div>

	<div id="validator-badges">
		<p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
		<p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
			Rdoc Generator</a> 1.1.6</small>.</p>
	</div>

</body>
</html>

